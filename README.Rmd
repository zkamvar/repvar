---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# repvar

[![lifecycle](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![Travis build status](https://travis-ci.org/zkamvar/repvar.svg?branch=master)](https://travis-ci.org/zkamvar/repvar)
[![Coverage status](https://codecov.io/gh/zkamvar/repvar/branch/master/graph/badge.svg)](https://codecov.io/github/zkamvar/repvar?branch=master)

The goal of repvar is to find the minimum number of samples that will represent
all variables in a data set. This was built for population genetic data, but is
generalizable to any discrete data type that can be represented as an integer
matrix. 

## Installation

This package is not currently on CRAN, but you can install it like so:

```{r inst, eval = FALSE}
# install.packages("remotes") # or devtools or ghit
remotes::install_github("zkamvar/repvar")
```


## Example

Here is a basic example of how you can identify the minimum set. We will use the
pre-packaged `monilinia` data set from Everhart and Scherm 2016.

```{r example}
options(width = 120)

library("repvar")
data(monilinia)
dim(monilinia)
print.table(monilinia[1:10, 1:10], zero.print = ".")

# Shuffle the data set 200 times to find an optimal number of samples
set.seed(2018)
id_list <- find_samples(monilinia, n = 200, cut = TRUE)
id_list
lengths(id_list)
print.table(monilinia[id_list[[1]], 1:10], zero.print = ".")
```

Because you get a list of ids, it's good to see which ones are actually useful.
For this, you can calculate entropy. We will use the tidyverse to first create
a table of samples and data, calculate entropy for each row, and then join them
together. In general, we will want higher entropy values. 

```{r tibble}
library("tibble")
library("dplyr")
library("tidyr")
id_df <- tibble::enframe(id_list, name = "ID", value = "samples") %>%
  dplyr::rowwise() %>%
  dplyr::mutate(data = list(monilinia[samples, ]))
id_df

# Calculate entropy for each entry
dplyr::mutate(id_df, diversity = list(entropy(monilinia[samples, ]))) %>%
  dplyr::select(ID, diversity) %>%
  tidyr::unnest() %>%
  dplyr::inner_join(id_df, by = "ID")
```

